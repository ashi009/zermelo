package zfloat32

import (
	"log"
	"math"
	"math/rand"
	"time"
	"testing"
)

func TestSort(t *testing.T) {
	r := []float32{3.1415, -1000.0, -1.0, 100.5, 0, 999}
	Sort(r)
	if !float32sAreSorted(r) {
		log.Printf("Should have sorted slice.\n")
		log.Printf("Data was %v", r)
		t.FailNow()
	}
}

func TestSortEmpty(t *testing.T) {
	r := []float32{}
	Sort(r)
	if len(r) != 0 {
		log.Printf("Should have been empty\n")
		t.FailNow()
	}
}

func TestSortRand(t *testing.T) {
	data := make([]float32, 2048)
	for iter := 0; iter < 100; iter++ {
		randomizeSlice(data)
		Sort(data)
		if !float32sAreSorted(data) {
			log.Printf("Should have sorted slice.\n")
			log.Printf("Data was %v", data)
			t.FailNow()
		}
	}
}

func float32sAreSorted(data []float32) bool {
	if len(data) == 0 {
		return true
	}
	for idx, x := range data {
		if idx == 0 {
			continue
		}
		if x < data[idx-1] {
			return false
		}
	}
	return true
}

// I was unhappy with the random float values generated by testing/quick
func randomizeSlice(data []float32) {
	rng := rand.New(rand.NewSource(time.Now().UnixNano()))
	for idx, _ := range(data) {
		mant := rng.Float32()
		exp := float64(rng.Intn(127))
		signs := rng.Intn(4)
		if (signs & 1) > 0 {
			exp *= -1
		}
		if (signs & 2) > 0 {
			mant *= -1
		}
		data[idx] = mant * float32(math.Pow(2.0, exp))
	}
}
